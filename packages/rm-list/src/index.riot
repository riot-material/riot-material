<rm-list onkeydown={ _onkeydown } onmousedown={ _updateCurrent } onmousemove={ _updateCurrent } onmouseleave={ _onmouseleave }>
    <slot></slot>

    <style>
        :host {
            display: block;
            outline: none;
        }
    </style>

    <script>
        import { tabbable, focusable, isFocusable } from "tabbable";
        import { __ as _r } from "riot";
        import { ripple, isRipple } from "@riot-material/ripple";

        const TABINDEX = Symbol("tabindex");
        const RIPPLE_HIGHLIGHT = Symbol("ripple-highlight");

        function disableTabbable(tabbable, definitely) {
            tabbable[TABINDEX] = tabbable.getAttribute("tabindex");
            if (definitely) {
                tabbable.removeAttribute("tabindex");
            } else {
                tabbable.setAttribute("tabindex", "-1");
            }
        }
        function enableTabbable(tabbable) {
            if (tabbable[TABINDEX] === undefined) {
                return;
            }
            tabbable.setAttribute("tabindex", tabbable[TABINDEX]);
        }
        function restoreTabbable(tabbable) {
            enableTabbable(tabbable);
            delete tabbable[TABINDEX];
        }

        export default {
            _onkeydown(event) {
                if (this.getPreventFocus()) {
                    return;
                }
                switch (event.key) {
                    case "ArrowDown": {
                        this.highlightNext();
                        break;
                    }
                    case "ArrowUp": {
                        this.highlightPrevious();
                        break;
                    }
                    default: {
                        return;
                    }
                }
                event.preventDefault();
            },
            _onmouseleave() {
                if (!this.getPreventFocus() || this._lastHighlight == null || this.getKeepHighlight()) {
                    return;
                }
                this.lessen();
            },
            getItems() {
                return Array.prototype.filter.call(this.root.querySelectorAll("rm-list-item"), item => {
                    return item[TABINDEX] !== undefined || isFocusable(item);
                });
            },
            onMounted() {
                [
                    "highlightCurrent",
                    "highlightNext",
                    "highlightPrevious",
                    "isHighlighted",
                    "getCurrent",
                    "lessen",
                    "setIndex"
                ].forEach(method => {
                    this.root[method] = this[method].bind(this);
                });

                const preventFocus = this.getPreventFocus();
                this.getItems().forEach((item, index) => {
                    if (this.getSingleHighlight() && isRipple(item)) {
                        const obj = ripple(item);
                        item[RIPPLE_HIGHLIGHT] = obj.getOption("highlight") || null;
                        obj.set({ highlight: false });
                    }
                    if (index === 0 && !preventFocus) {
                        return;
                    }
                    tabbable(item).forEach(disableTabbable);
                    disableTabbable(item, preventFocus);
                });
            },
            onBeforeUpdate() {
                this.getItems().forEach((item, index) => {
                    focusable(item, { includeContainer: true }).forEach(restoreTabbable);
                    if (isRipple(item) && item[RIPPLE_HIGHLIGHT] !== undefined) {
                        ripple(item, { highlight: item[RIPPLE_HIGHLIGHT] });
                        delete item[RIPPLE_HIGHLIGHT];
                    }
                });
            },
            onUpdated() {
                const preventFocus = this.getPreventFocus();
                const items = this.getItems();
                items.forEach((item, index) => {
                    if (this.getSingleHighlight() && isRipple(item)) {
                        const obj = ripple(item);
                        item[RIPPLE_HIGHLIGHT] = obj.getOption("highlight") || null;
                        obj.set({ highlight: false });
                    }
                    if (index === this._index && !preventFocus) {
                        return;
                    }
                    tabbable(item).forEach(disableTabbable);
                    disableTabbable(item, preventFocus);
                });
                this._index = Math.max(0, Math.min(this._index, items.length - 1));
            },
            _index: 0,
            _lastHighlight: null,
            _lastHighlighted: null,
            _updateCurrent(event) {
                const singleHighlight = this.getSingleHighlight();
                if (event.type === "mousemove" && !singleHighlight) {
                    return;
                }
                const preventFocus = this.getPreventFocus();
                if (preventFocus) {
                    event.preventDefault();
                }
                parent = event.target;
                while (
                    parent != null && parent !== this.root &&
                    parent.tagName !== "RM-LIST-ITEM" &&
                    [parent.getAttribute(_r.globals.IS_DIRECTIVE)].map(i => i && i.toUpperCase())[0] !== "RM-LIST-ITEM"
                ) {
                    parent = parent.parentElement;
                }
                if (parent == null || parent === this.root) {
                    return;
                }
                const items = this.getItems();
                if (!Array.prototype.some.call(items, (item, index) => {
                    if (parent === item) {
                        if (this._index === index) {
                            return true;
                        }
                        if (this._index < items.length) {
                            const lastItem = items[this._index];
                            tabbable(lastItem).forEach(disableTabbable);
                            disableTabbable(lastItem, preventFocus);
                        }
                        this._index = index;
                        focusable(item, { includeContainer: true }).forEach(enableTabbable);
                        this.root.dispatchEvent(new Event("currentchange"));
                        return true;
                    }
                    return false;
                })) {
                    if (preventFocus && !this.getKeepHighlight()) {
                        this.lessen();
                        return;
                    }
                }
                if (
                    preventFocus &&
                    (!this.getPreventHighlight() || this._lastHighlight != null ||
                    (singleHighlight && event.type === "mousemove"))
                ) {
                    this.highlightCurrent();
                }
            },
            highlightCurrent() {
                const item = this.getCurrent();
                if (this._lastHighlighted === item) {
                    return;
                }
                if (this.getPreventFocus()) {
                    this.lessen();
                    this._lastHighlighted = item;
                    this._lastHighlight = isRipple(item) ? ripple(item).highlight() : null;
                } else {
                    item.focus();
                }
                this.root.dispatchEvent(new Event("highlightchange"));
            },
            highlightNext() {
                const items = this.getItems();
                if (this._index >= items.length - 1) {
                    this.highlightCurrent();
                    return;
                }
                const target = items[this._index + 1];
                this._updateCurrent({ preventDefault() {}, target });
                this.highlightCurrent();
            },
            highlightPrevious() {
                const items = this.getItems();
                if (this._index <= 0) {
                    this.highlightCurrent();
                    return;
                }
                const target = items[this._index - 1];
                this._updateCurrent({ preventDefault() {}, target });
                this.highlightCurrent();
            },
            lessen() {
                if (this._lastHighlight != null) {
                    this._lastHighlight.end();
                    this._lastHighlight = null;
                    this._lastHighlighted = null;
                }
            },
            getPreventFocus() {
                return this.props.preventFocus != null && this.props.preventFocus !== false;
            },
            getPreventHighlight() {
                return this.props.preventHighlight != null && this.props.preventHighlight !== false;
            },
            getSingleHighlight() {
                return this.props.singleHighlight != null && this.props.singleHighlight !== false;
            },
            getKeepHighlight() {
                return this.props.keepHighlight != null && this.props.keepHighlight !== false;
            },
            getCurrent() {
                const items = this.getItems();
                return items[Math.max(0, Math.min(this._index, items.length - 1))];
            },
            isHighlighted() {
                return this.getPreventFocus() ? this._lastHighlight != null : this.getCurrent() === document.activeElement;
            },
            setIndex(index) {
                const items = this.getItems();
                index = Math.max(0, Math.min(index, items.length - 1));
                if (isNaN(index)) {
                    return;
                }
                const wasHighlighted = this.isHighlighted();
                const target = items[index];
                this._updateCurrent({ preventDefault() {}, target });
                if (wasHighlighted) {
                    this.highlightCurrent();
                }
            }
        }
    </script>
</rm-list>