<rm-textfield>
    <rm-textfield-container variant={ props.variant }
        label={ props.label } full-width={ isFullWidth() } disabled={ isDisabled() }
        class={ _getTextfieldContainerClass() } onmousedown={ _oncontainermousedown }
    >
        <input oninput={ _oninputinput }
            type={ getType() } value={ props.value } name={ props.name }
            disabled={ isDisabled() } slot="input"
        >
        <slot name="leading" slot="leading" />
        <span style="white-space: nowrap;" slot="trailing">
            <rm-button variant="icon" onclick={ clear }
                if={ isClearable() && root.value } dense tabindex={ isDisabled() ? "-1" : null }
            >clear</rm-button>
            <slot name="trailing" />
        </span>
    </rm-textfield-container>

    <style>
        :host {
            cursor: text;
        }
        :host[disabled] {
            cursor: default;
        }

        input {
            padding: 0;
            font-size: inherit;
            line-height: inherit;
            border: 0;
            background: none;
            outline: none;
            width: 100%;
            color: currentColor;
        }
    </style>

    <script>
        import TextfieldContainerComponent from "@riot-material/rm-textfield-container";

        export default {
            _input: null,
            onBeforeMount() {
                Object.defineProperty(this.root, "value", {
                    get: () => {
                        return this._input ? this._input.value : this.props.value || "";
                    },
                    set: value => {
                        this._input.value = value;
                    }
                });
            },
            _onfocus: null,
            _onblur: null,
            onMounted() {
                this._input = this.root.querySelector("input");
                window.addEventListener("focus", this._onfocus = event => {
                    if (event.target !== this._input) {
                        return;
                    }
                    event.stopImmediatePropagation();
                    this.update({ focused: true });
                    this.root.dispatchEvent(new FocusEvent("focus", { bubbles: false, cancelable: false }));
                }, true);
                window.addEventListener("blur", this._onblur = event => {
                    if (event.target !== this._input) {
                        return;
                    }
                    event.stopImmediatePropagation();
                    this.update({ focused: false });
                    this.root.dispatchEvent(new FocusEvent("blur", { bubbles: false, cancelable: false }));
                }, true);
            },
            onBeforeUnmount() {
                window.removeEventListener("focus", this._onfocus, true);
                window.removeEventListener("blur", this._onblur, true);
            },
            _oncontainermousedown(event) {
                if (this.props.disabled) {
                    return;
                }
                const input = this.root.querySelector("input");
                if (document.activeElement !== input){
                    event.preventDefault();
                    input.focus();
                }
            },
            _oninputinput() {
                this.update();
            },
            _getTextfieldContainerClass() {
                const names = {};
                if (this.state.focused) {
                    names["rm-focused"] = names["rm-label-should-float"] = true;
                }
                if (this.root.value) {
                    names["rm-label-should-float"] = true;
                }
                return Object.keys(names).join(" ");
            },
            getType() {
                switch (this.props.type) {
                    case "email": {
                        return "email";
                    }
                    case "number": {
                        return "number";
                    }
                    case "password": {
                        return "password";
                    }
                    case "search": {
                        return "search";
                    }
                    case "tel": {
                        return "tel";
                    }
                    case "url": {
                        return "url";
                    }
                    default: {
                        return "text";
                    }
                }
            },
            isClearable() {
                return this.props.clearable != null && this.props.clearable !== false;
            },
            isDisabled() {
                return this.props.disabled != null && this.props.disabled !== false;
            },
            isFullWidth() {
                return this.props.fullWidth != null && this.props.fullWidth !== false;
            },
            clear() {
                this.root.value = "";
                this.update();
            },
            components: {
                "rm-textfield-container": TextfieldContainerComponent
            }
        }
    </script>
</rm-textfield>