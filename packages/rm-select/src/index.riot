<rm-select>
    <rm-menu onselected={ _onmenuselected } opened={ state.menuopened } inherit-width prevent-close-on-click-out
        prevent-focus variant={ getVariant() } selected={ state.selected } keep-highlight
        onopen={ dispatchMenuEvent } onclose={ dispatchMenuEvent }
    ><div ref="rm-select-menu"><slot></slot></div></rm-menu>
    <rm-textfield-container variant={ getVariant() }
        label={ props.label } full-width={ isFullWidth() }
        class={ _getClassNames() } disabled={ isDisabled() }
    >
        <span slot="input">
            <input onfocus={ _oninputfocus } onblur={ _oninputblur } oninput={ _oninputinput }
                readonly={ !isFilterable() } class="rm-select--input" disabled={ isDisabled() }
            >
            <div class="rm-select--label">{ getLabel() }</div>
        </span>
        <slot name="leading" slot="leading" />
        <span style="white-space: nowrap;" slot="trailing">
            <rm-button variant="icon" class="rm-select--clear" dense
                onclick={ clear } if={ isClearable() && root.value } tabindex={ isDisabled() ? "-1" : null }
            >clear</rm-button>
            <slot name="trailing" />
            <rm-button variant="icon" class="rm-select--arrow{
                state.menuopened ? ' rm-select--arrow-rotated' : ''
            }" tabindex="-1" dense>arrow_drop_down</rm-button>
        </span>
    </rm-textfield-container>

    <style>
        :host {
            position: relative;
        }
        :host[filterable] {
            cursor: text;
        }
        :host[disabled] {
            cursor: default;
        }

        /* ARROW */
        :host .rm-select--arrow {
            transition: transform ease-in-out 150ms;
            transform: rotate(0deg);
        }
        :host .rm-select--arrow.rm-select--arrow-rotated {
            transform: rotate(180deg);
        }

        /* INPUT */
        :host .rm-select--input {
            padding: 0;
            font-size: inherit;
            line-height: inherit;
            border: 0;
            background: none;
            outline: none;
            opacity: 0;
            cursor: default;
            width: 100%;
            color: currentColor;
        }
        :host[filterable]:not([filterable=false]) .rm-select--input {
            opacity: 1;
            cursor: text;
        }

        /* LABEL */
        :host .rm-select--label {
            position: absolute;
            top: 0; left: 0;
            font-size: inherit;
            line-height: inherit;
        }
        :host[filterable]:not([filterable=false]) .rm-select--label {
            display: none;
        }
    </style>

    <script>
        import TextfieldContainerComponent from "@riot-material/rm-textfield-container";
        import ButtonComponent from "@riot-material/rm-button";
        import MenuComponent from "@riot-material/rm-menu";
        import { ripple } from "@riot-material/ripple";

        import "@riot-material/before-focus-listener";
        import { __ as __r } from "riot";

        const blockedInputs = [];
        window.addEventListener("change", event => {
            if (blockedInputs.some(input => event.target === input)) {
                event.stopImmediatePropagation();
            }
        }, true);

        export default {
            _mounted: false,
            _menu: null,
            _input: null,
            _onmenuselected(event) {
                this._lastSelectedOption = event.target;
                this.update({ refreshLabel: true, menuopened: false });
                this.dispatchMenuEvent(event);
            },
            onBeforeMount() {
                Object.defineProperties(this.root, {
                    value: {
                        get: () => {
                            const selected = this.getSelected().map(option => option.value);
                            return this.isMultiple() ? selected : selected[0] || "";
                        },
                        set: value => {
                            let option = null;
                            if (this.getOptions().some(opt => {
                                if (opt.value == value) {
                                    option = opt;
                                    return true;
                                }
                                return false;
                            })) {
                                this.select(option);
                            }
                        }
                    },
                    label: {
                        get: () => {
                            return this._input ? this._input.label : "";
                        }
                    }
                });
            },
            _onclickFirstChild: null,
            _onclickArrow: null,
            onMounted() {
                let _lastSelectedOption = null;
                Object.defineProperty(this, "_lastSelectedOption", {
                    set(option) {
                        if (option === this._lastSelectedOption) {
                            return;
                        }
                        const newOptionComponent = option[__r.globals.DOM_COMPONENT_INSTANCE_PROPERTY];
                        if (newOptionComponent != null) {
                            newOptionComponent.update({ selected: true });
                        }
                        if (_lastSelectedOption != null && !this.isMultiple()) {
                            const lastOptionComponent = _lastSelectedOption[__r.globals.DOM_COMPONENT_INSTANCE_PROPERTY];
                            if (lastOptionComponent != null) {
                                lastOptionComponent.update({ selected: false });
                            }
                        }
                        _lastSelectedOption = option;
                    },
                    get() {
                        return _lastSelectedOption;
                    }
                });

                const input = this._input = this.root.querySelector("input");
                
                Object.defineProperties(input, {
                    value: {
                        get: () => this.root.value,
                        set: value => { this.root.value = value }
                    },
                    label: {
                        get: () => this.getLabel()
                    },
                    filter: {
                        get: () => this.getFilter()
                    }
                });

                this.root.children[1].addEventListener("keydown", event => {
                    if (!this.state.menuopened && [ " " ].some(key => event.key === key)) {
                        this.update({ menuopened: true });
                        event.stopImmediatePropagation();
                    } else if (this.state.menuopened && [ "Escape" ].some(key => event.key === key)) {
                        this.update({ menuopened: false });
                        event.stopImmediatePropagation();
                    } else if (!this.state.menuopened) {
                        switch (event.key) {
                            case "ArrowDown": {
                                if (this.isMultiple() || this.isFilterable()) {
                                    this.update({ menuopened: true });
                                } else {
                                    const options = this.getOptions();
                                    if (options.length !== 0) {
                                        let index = -1;
                                        if (options.some((option, i) => {
                                            if (option === this._lastSelectedOption) {
                                                index = i;
                                                return true;
                                            }
                                            return false;
                                        })) {
                                            if (++index < options.length) {
                                                this._lastSelectedOption = options[index];
                                                this.update();
                                            }
                                        }
                                    }
                                }
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                break;
                            }
                            case "ArrowUp": {
                                if (this.isMultiple() || this.isFilterable()) {
                                    this.update({ menuopened: true });
                                } else {
                                    const options = this.getOptions();
                                    if (options.length !== 0) {
                                        let index = -1;
                                        if (options.some((option, i) => {
                                            if (option === this._lastSelectedOption) {
                                                index = i;
                                                return true;
                                            }
                                            return false;
                                        })) {
                                            if (--index >= 0) {
                                                this._lastSelectedOption = options[index];
                                                this.update();
                                            }
                                        }
                                    }
                                }
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                break;
                            }
                        }
                    }
                });
                this._selectMenu = this.root.querySelector("[ref='rm-select-menu']");
                (this._menu = this.root.firstElementChild)._bindTo(this.root.children[1]);

                blockedInputs.push(input);

                this.root.firstElementChild.addEventListener("beforefocus", this._onclickFirstChild = event => {
                    if (this.props.disabled) {
                        return;
                    }
                    if (document.activeElement !== input) {
                        if (!this.state.menuopened) {
                            this.update({ menuopened: true });
                        }
                        event.preventDefault();
                        input.focus();
                    } else if (!this.isFilterable()) {
                        this.update({ menuopened: !this.state.menuopened });
                    }
                });
                this.root.querySelector(".rm-select--arrow").addEventListener("beforefocus", this._onclickArrow = event => {
                    if (this.props.disabled) {
                        return;
                    }
                    if (this.isFilterable()) {
                        this.update({ menuopened: !this.state.menuopened });
                    }
                });

                this._mounted = true;

                const options = this.getOptions();
                if (options.length) {
                    options.forEach(option => {
                        if (option.selected) {
                            this._lastSelectedOption = option;
                        }
                    });

                    if (this._lastSelectedOption == null) {
                        this._lastSelectedOption = options[0];
                    }

                    this._lastSelected = this.getSelected();
                    HTMLInputElement.prototype.__lookupSetter__("value").call(input, this.getLabel());
                    this.update();
                } else {
                    this._lastSelected = [];
                }

                this._manipulate();
            },
            onBeforeUnmount() {
                this._restoreManipulated();
                let index;
                if (blockedInputs.some((input, i) => {
                    index = i;
                    return this._input === input;
                })) {
                    blockedInputs.splice(index, 1);
                }
                this.root.firstElementChild.removeEventListener("beforefocus", this._onclickFirstChild);
                this.root.querySelector(".rm-select--arrow").removeEventListener("beforefocus", this._onclickArrow);
            },
            _manipulated: [],
            _manipulate() {
                this._selectMenu.querySelectorAll("option").forEach(option => {
                    const container = document.createElement("div");
                    option.replaceWith(container);
                    option.setAttribute("menu-option", "");
                    option.style.padding = "8px 12px";
                    container.appendChild(option);
                    ripple(container, { highlight: true });
                    this._manipulated.push(option);
                });
            },
            _restoreManipulated() {
                while (this._manipulated.length > 0) {
                    const option = this._manipulated.pop();
                    const container = option.parentElement;
                    container.removeChild(option);
                    container.replaceWith(option);
                }
            },
            _lastSelected: null,
            onBeforeUpdate() {
                // this._restoreManipulated();
            },
            onUpdated() {
                // this._manipulate();
                if (this.state.refreshLabel || document.activeElement !== this._input) {
                    HTMLInputElement.prototype.__lookupSetter__("value").call(this._input, this.getLabel());
                    delete this.state.refreshLabel;
                    delete this.state.filtering;
                }
                const selected = this.getSelected();
                if (selected.some((option, i) => option !== this._lastSelected[i])) {
                    this._lastSelected = selected;
                    this.root.dispatchEvent(new Event("change"));
                }
            },
            _oninputfocus() {
                this._labelWhenOnFocus = this.root.label;
                this.update({ focused: true }); // , menuopened: true });
            },
            _oninputblur() {
                this.update({ focused: false, menuopened: false, refreshLabel: true });
            },
            _oninputinput() {
                this.state.filtering = true;
                if (this.isFilterable() && !this.state.menuopened) {
                    this.update({ menuopened: true });
                }
            },
            _getClassNames() {
                const classNames = {};
                if (this.state.focused) {
                    classNames["rm-focused"] = true;
                    if (this.isFilterable()) {
                        classNames["rm-label-should-float"] = true;
                    }
                }
                const label = this.getLabel();
                if (label !== "") {
                    classNames["rm-label-should-float"] = true;
                }
                return Object.keys(classNames).join(" ");
            },
            clear() {
                this.update({ menuopened: true, refreshLabel: true });
            },
            getSelected() {
                return this.getOptions().filter(option => option.selected && !option.disabled);
            },
            getOptions() {
                return this._menu != null ? this._menu.options : [];
            },
            getLabel() {
                return this.getSelected().map(option => option.label).join(", ");
            },
            getVariant() {
                switch (this.props.variant) {
                    case "outlined": return "outlined";
                    case "filled": return "filled";
                    default: return "flat";
                }
            },
            isFilterable() {
                return this.props.filterable != null && this.props.filterable !== "false" && this.props.filterable !== false;
            },
            isMultiple() {
                return false;
            },
            isClearable() {
                return this.props.clearable != null && this.props.clearable !== false;
            },
            isDisabled() {
                return this.props.disabled != null && this.props.disabled !== false;
            },
            isFullWidth() {
                return this.props.fullWidth != null && this.props.fullWidth !== false;
            },
            select(option) {
                if (option.selected) {
                    return;
                }
                if (!this.isMultiple()) {
                    const selected = this.getSelected()[0];
                    if (selected) {
                        selected.selected = false;
                    }
                }
                option.selected = true;
                this._lastSelectedOption = option;
                if (this._mounted) {
                    this.update({ menuopened: this.isMultiple() ? this.state.menuopened : false, refreshLabel: true });
                }
                HTMLInputElement.prototype.__lookupSetter__("value").call(this._input, this.getLabel());
            },
            getFilter() {
                return this.state.filtering ?
                    HTMLInputElement.prototype.__lookupGetter__("value").call(this._input, this.getLabel())
                    : null
                ;
            },
            dispatchMenuEvent(event) {
                this.root.dispatchEvent(new CustomEvent("menu" + event.type, {
                    detail: { originatingEvent: event }
                }));
            },
            components: {
                "rm-textfield-container": TextfieldContainerComponent,
                "rm-button": ButtonComponent,
                "rm-menu": MenuComponent
            }
        }
    </script>
</rm-select>