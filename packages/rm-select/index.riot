<rm-select>
    <rm-menu onselected={ _onmenuselected } opened={ state.menuopened } inherit-width prevent-close-on-click-out
        prevent-focus variant={ props.variant } selected={ state.selected } keep-highlight
    ><slot /></rm-menu>
    <rm-textfield-container variant={ props.variant }
        label={ props.label } full-width={ props.fullWidth }
        class={ _getClassNames() } disabled={ props.disabled }
    >
        <span slot="input">
            <input onfocus={ _oninputfocus } onblur={ _oninputblur } oninput={ _oninputinput }
                readonly={ !isFilterable() } class="rm-select--input" disabled={ props.disabled }
            >
            <div class="rm-select--label">{ getLabel() }</div>
        </span>
        <slot name="leading" slot="leading" />
        <span style="white-space: nowrap;" slot="trailing">
            <rm-button variant="icon" class="rm-select--clear" dense
                onclick={ clear } if={ isClearable() && root.value } tabindex={ props.disabled ? "-1" : null }
            >clear</rm-button>
            <slot name="trailing" />
            <rm-button variant="icon" class="rm-select--arrow{
                state.menuopened ? ' rm-select--arrow-rotated' : ''
            }" tabindex="-1" dense>arrow_drop_down</rm-button>
        </span>
    </rm-textfield-container>

    <style>
        :host {
            position: relative;
        }
        :host[filterable] {
            cursor: text;
        }
        :host[disabled] {
            cursor: default;
        }

        /* ARROW */
        :host .rm-select--arrow {
            transition: transform ease-in-out 150ms;
            transform: rotate(0deg);
        }
        :host .rm-select--arrow.rm-select--arrow-rotated {
            transform: rotate(180deg);
        }

        /* INPUT */
        :host .rm-select--input {
            padding: 0;
            font-size: inherit;
            line-height: inherit;
            border: 0;
            background: none;
            outline: none;
            opacity: 0;
            cursor: default;
            width: 100%;
            color: currentColor;
        }
        :host[filterable]:not([filterable=false]) .rm-select--input {
            opacity: 1;
            cursor: text;
        }

        /* LABEL */
        :host .rm-select--label {
            position: absolute;
            top: 0; left: 0;
            font-size: inherit;
            line-height: inherit;
        }
        :host[filterable]:not([filterable=false]) .rm-select--label {
            display: none;
        }
    </style>

    <script>
        import TextfieldContainerComponent from "@riot-material/rm-textfield-container";
        import ButtonComponent from "@riot-material/rm-button";
        import MenuComponent from "@riot-material/rm-menu";

        // import * as riot from "riot";

        import beforeFocusListener from "@riot-material/before-focus-listener";

        const blockedInputs = [];
        window.addEventListener("change", event => {
            if (blockedInputs.some(input => event.target === input)) {
                event.stopImmediatePropagation();
            }
        }, true);

        export default {
            state: {
                selected: [],
            },
            _mounted: false,
            _menu: null,
            _input: null,
            onBeforeMount() {
                const valueProperty = {
                    get: () => {
                        const selected = this.state.selected;
                        return this.isMultiple() ? selected : selected[0] || "";
                    },
                    set: value => {
                        this.select(value);
                    }
                };
                Object.defineProperty(this.root, "value", valueProperty);
                Object.defineProperty(this.root, "label", { get: () => {
                    return this._input ? this._input.label : "";
                } });
            },
            _onclickFirstChild: null,
            _onclickArrow: null,
            onMounted() {
                const input = this._input = this.root.querySelector("input");
                
                Object.defineProperty(input, "value", {
                    get: () => this.root.value,
                    set: value => { this.root.value = value }
                });

                Object.defineProperty(input, "label", { get: HTMLInputElement.prototype.__lookupGetter__("value").bind(input) });

                this.root.children[1].addEventListener("keydown", event => {
                    if (!this.state.menuopened && [ 32 ].some(keyCode => event.keyCode === keyCode)) {
                        this.update({ menuopened: true });
                        event.stopImmediatePropagation();
                    } else if (this.state.menuopened && [ 27 ].some(keyCode => event.keyCode === keyCode)) {
                        this.update({ menuopened: false });
                        event.stopImmediatePropagation();
                    } else if (!this.state.menuopened) {
                        switch (event.keyCode) {
                            case 40: {
                                if (this.isMultiple() || this.isFilterable()) {
                                    this.update({ menuopened: true });
                                } else {
                                    const options = this._menu.options;
                                    if (options.length !== 0) {
                                        if (this.state.selected.length === 0) {
                                            this.root.value = options[0].value;
                                        } else {
                                            const value = this.state.selected[0];
                                            let index = 0;
                                            for (let i = 0; i < options.length; i++) {
                                                const opt = options[i];
                                                if (opt.value === value) {
                                                    index = i;
                                                    break;
                                                }
                                            }
                                            if (index + 1 < options.length) {
                                                this.root.value = options[index + 1].value;
                                            }
                                        }
                                    }
                                }
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                break;
                            }
                            case 38: {
                                if (this.isMultiple() || this.isFilterable()) {
                                    this.update({ menuopened: true });
                                } else {
                                    const options = this._menu.options;
                                    if (options.length !== 0) {
                                        if (this.state.selected.length === 0) {
                                            this.root.value = options[0].value;
                                        } else {
                                            const value = this.state.selected[0];
                                            let index = 0;
                                            for (let i = options.length - 1; i >= 0; i--) {
                                                const opt = options[i];
                                                if (opt.value === value) {
                                                    index = i;
                                                    break;
                                                }
                                            }
                                            if (index - 1 >= 0) {
                                                this.root.value = options[index - 1].value;
                                            }
                                        }
                                    }
                                }
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                break;
                            }
                        }
                    }
                });
                (this._menu = this.root.firstElementChild)._bindTo(this.root.children[1]);

                blockedInputs.push(input);

                beforeFocusListener.addListener(this.root.firstElementChild, this._onclickFirstChild = event => {
                    if (this.props.disabled) {
                        return;
                    }
                    if (document.activeElement !== input) {
                        if (!this.state.menuopened) {
                            this.update({ menuopened: true });
                        }
                        event.preventDefault();
                        input.focus();
                    } else if (!this.isFilterable()) {
                        this.update({ menuopened: !this.state.menuopened });
                    }
                });
                beforeFocusListener.addListener(this.root.querySelector(".rm-select--arrow"), this._onclickArrow = event => {
                    if (this.props.disabled) {
                        return;
                    }
                    if (this.isFilterable()) {
                        this.update({ menuopened: !this.state.menuopened });
                    }
                });

                this._lastSelected = this.state.selected.sort();
                {
                    // const selected = this.getSelected();
                    // for (let i = selected.length - 1; i >= 0; i--) {
                    //     const item = selected[i];
                    //     const riotInstance = item[riot.__.globals.DOM_COMPONENT_INSTANCE_PROPERTY];
                    //     if (riotInstance && riotInstance.name === "rm-menu-item") {
                    //         item.firstElementChild.classList.add("rm-ripple-container--highlighted");
                    //     }
                    // }
                }

                this._mounted = true;
                // this.state.selectedOption = option;
                // HTMLInputElement.prototype.__lookupSetter__("value").call(input, this.getLabel());
            },
            onBeforeUnmount() {
                let index;
                if (blockedInputs.some((input, i) => {
                    index = i;
                    return this._input === input;
                })) {
                    blockedInputs.splice(i, 1);
                }
                beforeFocusListener.removeListener(this.root.firstElementChild, this._onclickFirstChild);
                beforeFocusListener.removeListener(this.root.querySelector(".rm-select--arrow"), this._onclickArrow);
            },
            _lastSelected: null,
            onBeforeUpdate() {
                if (this.state.refreshLabel) {
                    HTMLInputElement.prototype.__lookupSetter__("value").call(this.root.querySelector("input"), this.getLabel());
                    delete this.state.refreshLabel;
                }
            },
            onUpdated() {
                const selected = this.state.selected.sort();
                if (selected.length !== this._lastSelected.length || selected.some((item, i) => {
                    return item !== this._lastSelected[i];
                })) {
                    this._lastSelected = selected;
                    this.root.dispatchEvent(new Event("change"));
                }
            },
            _oninputfocus() {
                this._labelWhenOnFocus = this.root.label;
                this.update({ focused: true }); // , menuopened: true });
            },
            _oninputblur() {
                this.update({ focused: false, menuopened: false, refreshLabel: true });
            },
            _oninputinput() {
                if (this.isFilterable() && !this.state.menuopened) {
                    this.update({ menuopened: true });
                }
            },
            _getClassNames() {
                const classNames = {};
                if (this.state.focused) {
                    classNames["rm-focused"] = true;
                    if (this.isFilterable()) {
                        classNames["rm-label-should-float"] = true;
                    }
                }
                const label = this.getLabel();
                if (label !== "") {
                    classNames["rm-label-should-float"] = true;
                }
                return Object.keys(classNames).join(" ");
            },
            clear() {
                this.update({ selected: [], menuopened: true, refreshLabel: true });
            },
            getSelected() {
                if (this.state.selected.length === 0) {
                    return [];
                }
                return (this._menu || this.root).querySelectorAll(this.state.selected.map(value => {
                    return ["option", "rm-menu-item"].map(tag => {
                        const selectors = [ `[value='${value}']:not([disabled]):not([passive])` ];
                        if (!value) {
                            selectors.push(":not([value]):not([disabled]):not([passive])");
                        }
                        return selectors.map(selector => tag + selector).join(",");
                    }).join(",")
                }).join(","));
            },
            getOptions() {
                return this.root.querySelectorAll("option");
            },
            getLabel() {
                return Array.prototype.map.call(this.getSelected(), option => option.label).join(", ");
            },
            isFilterable() {
                return this.props.filterable != null && this.props.filterable !== "false" && this.props.filterable !== false;
            },
            isMultiple() {
                return false;
            },
            isClearable() {
                return this.props.clearable != null && this.props.clearable !== false;
            },
            select(value) {
                if (!this.hasSelected(value)) {
                    if (this.isMultiple()) {
                        this.state.selected.push(value);
                    } else {
                        this.state.selected = [value];
                    }
                }
                if (this._mounted) {
                    this.update({ menuopened: this.isMultiple() ? state.menuopened : false, refreshLabel: true });
                }
            },
            hasSelected(value) {
                return this.state.selected.some(s => s === value);
            },
            components: {
                "rm-textfield-container": TextfieldContainerComponent,
                "rm-button": ButtonComponent,
                "rm-menu": MenuComponent
            }
        }
    </script>
</rm-select>